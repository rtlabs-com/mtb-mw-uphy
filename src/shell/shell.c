/******************************************************************************
 * File Name:   shell.c
 *
 * Description: This is the source code for the XMC MCU: UART Shell Example
 *              for ModusToolbox. Code derived from fNET Shell
 *              (https://github.com/butok/FNET/)
 *
 * Related Document: See README.md
 *
 ******************************************************************************
 *
 * Copyright (c) 2015-2024, Infineon Technologies AG
 * All rights reserved.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *****************************************************************************/

#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <stdarg.h>
#include "shell.h"
#include "retarget_io.h"
#include "ring_buffer.h"

#include "cyhal.h"
#include "cybsp.h"
#include "cy_retarget_io.h"
#include "retarget_io.h"
#include "shell.h"

#include <FreeRTOS.h>
#include <task.h>
#include "osal.h"

/*******************************************************************************
 * Typedefs
 *******************************************************************************/
/* States of shell state machine */
typedef enum SHELL_STATE
{
   SHELL_STATE_INIT,           /* The Shell service is initialized to process
                                  next user command. */
   SHELL_STATE_GET_USER_INPUT, /* The Shell service is accepting user commands.
                                */
   SHELL_STATE_EXEC_CMD, /* The Shell service is executing user commands. */
   SHELL_STATE_END_CMD   /* The Shell service finished command execution. */
} SHELL_STATE_t;

/*******************************************************************************
 * Variables
 *******************************************************************************/

static const shell_cmd_t ** shell_cmd_table;
static int shell_cmd_table_sz = 0;
static SHELL_STATE_t shell_state;
static uint32_t shell_cmdline_pos;
static char shell_cmdline[SHELL_CMDLINE_SIZE];
static uint32_t shell_cmdline_prev_pos;
static char shell_cmdprev[SHELL_CMDLINE_SIZE];

/*
 * defined in linker script file uphy-linker-script.ld and used to
 * assemble all console commands defined in code using SHELL_CMD()
 * */
extern uint32_t cmds_start;
extern uint32_t cmds_end;

static TaskHandle_t console_task_hdl;

/*******************************************************************************
 * Macros
 *******************************************************************************/
/* Parameters of shell behaviour */
#define SHELL_ERR_SYNTAX ("Error: Invalid syntax for: %s")
#define SHELL_ERR_CMD    ("Error: No such command: %s")
#define SHELL_BACKSPACE  ((char)(0x08)) /* Backspace. */
#define SHELL_DELETE     ((char)(0x7F)) /* Delete. */
#define SHELL_CTRLC      ((char)(0x03)) /* Ctrl + C. */
#define SHELL_CR         ((char)(0x0D)) /* CR. */
#define SHELL_LF         ((char)(0x0A)) /* LF. */
#define SHELL_ESC        ((char)(0x1B)) /* Esc. */
#define SHELL_SPACE      ((char)(0x20)) /* Space. */

/* we entered handle_esc() when one character was available
 * ensure we don't attempt to read additional data from stdin
 * before new data is available in serial buffer */
static char wait_esc_data (void)
{
   while (ring_buffer_avail (&serial_buffer) == 0)
      vTaskDelay (1);
   return getchar();
}

void handle_esc (void)
{
   char c;

   c = wait_esc_data(); // Read the next character (usually '[')
   if (c == '[')
   {
      c = wait_esc_data(); // Read the next character to determine the key
      switch (c)
      {
      case 'A':

         /* arrow up, repeat previous command */
         memcpy (shell_cmdline, shell_cmdprev, SHELL_CMDLINE_SIZE);
         shell_cmdline_pos = shell_cmdline_prev_pos;

         /* clear line and rewrite command */
         printf ("\r\033[K%s%s", SHELL_PROMPT, shell_cmdline);
         fflush (stdout);
         break;
      case 'B':
         /* arrow down */
         break;
      case 'C':
         /* arrow right */
         break;
      case 'D':
         /* arrow left */
         break;
      default:
         printf ("Unknown escape sequence detected! [%x]\n", c);
         break;
      }
   }
}

/*******************************************************************************
 * Function Name: shell_println
 ********************************************************************************
 * Summary:
 * Wrapping of printf for formatted output including linefeed.
 *
 * Parameters:
 *  const char *format: format string
 *  ...: flexible parameter list for formatted output
 *
 *
 * Return:
 *  int32_t: number of characters printed
 *
 *******************************************************************************/
int32_t shell_println (const char * format, ...)
{
   int32_t result;
   va_list ap;

   va_start (ap, format);
   result = vprintf (format, ap);
   /* Add new line.*/
   result += printf ("\r\n");
   va_end (ap);

   return result;
}

/*******************************************************************************
 * Function Name: shell_make_argv
 ********************************************************************************
 * Summary:
 * Parsing parameters from user input before calling cmd callbacks
 *
 * Parameters:
 *  char *cmdline: command input received from terminal
 *  char *argv[]: parsed array of parameters (output)
 *
 *
 * Return:
 *  int32_t: count of parsed arguments
 *
 *******************************************************************************/
static int32_t shell_make_argv (char * cmdline, char * argv[])
{
   int32_t argc = 0;
   int32_t i;
   bool in_text_flag = false;

   if ((cmdline != NULL) && (argv != NULL))
   {
      for (i = 0u; cmdline[i] != '\0'; ++i)
      {
         if (cmdline[i] == ' ')
         {
            in_text_flag = false;
            cmdline[i] = '\0';
         }
         else
         {
            if (argc < SHELL_ARGS_MAX)
            {
               if (in_text_flag == false)
               {
                  in_text_flag = true;
                  argv[argc] = &cmdline[i];
                  argc++;
               }
            }
            else
            {
               /* Return argc.*/
               break;
            }
         }
      }

      argv[argc] = 0;
   }

   return argc;
}

/*******************************************************************************
 * Function Name: shell_state_machine
 ********************************************************************************
 * Summary:
 * Implementation of the shell internal state-machine.
 * see https://github.com/butok/FNET/ for implementation details
 *
 * Parameters:
 *  void
 *
 * Return:
 *  void
 *
 *******************************************************************************/
void shell_state_machine (void)
{
   /* One extra for 0 terminator.*/
   char * argv[SHELL_ARGS_MAX + 1u];
   int32_t argc;
   int32_t ch;

   switch (shell_state)
   {
   case SHELL_STATE_INIT:
      printf ("%s", SHELL_PROMPT);
      shell_state = SHELL_STATE_GET_USER_INPUT;
      break;

   case SHELL_STATE_GET_USER_INPUT:
      if (ring_buffer_avail (&serial_buffer) > 0)
      {
         ch = getchar();
         if (ch != EOF)
         {
            /* Check if
             * 1. enter was pressed or
             * 2. shell_cmdline buffer has only 1 character left, reserved for
             * zero termination
             */
            if (((char)ch != SHELL_LF) && (shell_cmdline_pos < (SHELL_CMDLINE_SIZE - 1)))
            {
               switch (ch)
               {
               case SHELL_ESC:
                  handle_esc();
                  break;
               case SHELL_BACKSPACE:
               case SHELL_DELETE:
                  if (shell_cmdline_pos > 0U)
                  {
                     shell_cmdline_pos -= 1U;
                     putchar (SHELL_BACKSPACE);
                     putchar (' ');
                     putchar (SHELL_BACKSPACE);
                  }
                  break;

               default:
                  if ((shell_cmdline_pos + 1U) < SHELL_CMDLINE_SIZE)
                  {
                     /* Only printable characters. */
                     if (((char)ch >= SHELL_SPACE) && ((char)ch <= SHELL_DELETE))
                     {
                        shell_cmdline[shell_cmdline_pos] = (char)ch;
                        shell_cmdline_pos++;
                        putchar ((char)ch);
                     }
                  }
                  break;
               }
            }
            else
            {
               /* Append zero termination to command and start execution */
               shell_cmdline[shell_cmdline_pos] = '\0';

               putchar (SHELL_CR);
               putchar (SHELL_LF);

               shell_state = SHELL_STATE_EXEC_CMD;
            }
         }
      }
      break;

   case SHELL_STATE_EXEC_CMD:

      /* store copy of command line before chopped up into separate arguments */
      if (strlen (shell_cmdline) > 0)
      {
         memcpy (shell_cmdprev, shell_cmdline, SHELL_CMDLINE_SIZE);
         shell_cmdline_prev_pos = strlen (shell_cmdprev);
      }

      argc = shell_make_argv (shell_cmdline, argv);

      if (argc != 0)
      {
         int i;
         const shell_cmd_t * cur_command = NULL;
         for (i = 0; i < shell_cmd_table_sz; i++)
         {
            cur_command = shell_cmd_table[i];

            /* Command is found. */
            if (strcasecmp (cur_command->name, argv[0]) == 0)
            {
               if (cur_command->cmd)
               {
                  int ret = cur_command->cmd (argc, argv);

                  if (ret == -1)
                     shell_println (SHELL_ERR_SYNTAX, argv[0]);
               }

               break;
            }
         }

         if (i == shell_cmd_table_sz)
         {
            shell_println (SHELL_ERR_CMD, argv[0]);
         }
      }

      shell_state = SHELL_STATE_END_CMD;
      break;

   case SHELL_STATE_END_CMD:
      shell_state = SHELL_STATE_INIT;
      shell_cmdline_pos = 0u;
      shell_cmdline[0] = 0u;
      break;

   default:
      break;
   }
}

/*******************************************************************************
 * Function Name: shell_init
 ********************************************************************************
 * Summary:
 * Initialize printf retarget
 *
 * Parameters:
 *  const shell_cmd_t_t *const cmd_table: Table to specify shell commands
 *  void (*init)(void): function ptr which is called at the end of
 *initialization e.g. to parse a welcome string to the terminal
 *
 * Return:
 *  void
 *
 *******************************************************************************/

static const shell_cmd_t * lookup (const char * name)
{
   unsigned int ix;
   const shell_cmd_t * cmd;

   for (ix = 0; ix < shell_cmd_table_sz; ix++)
   {
      cmd = shell_cmd_table[ix];
      if (strcmp (cmd->name, name) == 0)
      {
         return cmd;
      }
   }

   /* Command was not found */
   return NULL;
}

void shell_usage (const char * name, const char * msg)
{
   const shell_cmd_t * cmd = lookup (name);
   printf ("%s: %s\n", name, msg);
   printf ("usage:\n%s\n", cmd->help_long);
}

int _cmd_help (int argc, char * argv[])
{
   unsigned int ix;
   const shell_cmd_t * cmd;

   if (argc > 2)
   {
      shell_usage (argv[0], "too many arguments");
      return -1;
   }

   if (argc == 1)
   {
      /* List all commands */
      for (ix = 0; ix < shell_cmd_table_sz; ix++)
      {
         cmd = shell_cmd_table[ix];
         printf ("%-20s - %s\n", cmd->name, cmd->help_short);
      }
   }
   else if (argc == 2)
   {
      /* Show long help for given command */
      cmd = lookup (argv[1]);
      if (cmd != NULL)
      {
         printf ("%s\n", cmd->help_long);
      }
      else
      {
         printf ("Unknown command %s\n", argv[1]);
      }
   }

   return 0;
}

/*******************************************************************************
 * Function Name: my_shell_init
 ********************************************************************************
 * Summary:
 * Welcome screen shown when shell is initialized
 * Override this function to customize the welcome screen. This is done by
 * defining a function with the same name in the application code without the
 * weak attribute.
 *
 * Parameters:
 *  void
 *
 * Return:
 *  void
 *
 *******************************************************************************/
__attribute__ ((weak)) void shell_print_start_banner (void)
{
   const char DELIMITER_STR[] =
      "************************************************";

   /* \x1b[2J\x1b[;H - ANSI ESC sequence for clear screen */
   printf ("\x1b[2J\x1b[;H");

   shell_println ("\r\n%s", DELIMITER_STR);
   shell_println (" %s", "Shell Application");
   shell_println (DELIMITER_STR);
   shell_println (" Version %s", "1.0.0");
   shell_println (" Built %s", __DATE__ " at " __TIME__);

   shell_println ("\n Enter 'help' for command list.");
   shell_println ("%s\n", DELIMITER_STR);
}

static void my_shell_init (void)
{
   shell_print_start_banner();
}

static void shell_init (void (*init) (void))
{
   const shell_cmd_t ** cmds = (const shell_cmd_t **)&cmds_start;

   shell_cmd_table = cmds;
   shell_cmd_table_sz = &cmds_end - &cmds_start;

   setvbuf (stdout, NULL, _IONBF, 0);

   shell_state = SHELL_STATE_INIT;
   shell_cmdline_pos = 0u;
   shell_cmdline[0] = 0u;

   init();
}

static void console_task (void *)
{
   while (true)
   {
      shell_state_machine();
      vTaskDelay (1);
   }
}

void shell_console_init (void)
{
   cy_rslt_t result;

   /* Initialize retarget-io to use the debug UART port */
   /* Please note that _read() and _write() functions are re-defined in
    * retarget_io.c */

   result = cy_retarget_io_init_fc (
      CYBSP_DEBUG_UART_TX,
      CYBSP_DEBUG_UART_RX,
      NC,
      NC,
      CY_RETARGET_IO_BAUDRATE);

   CY_ASSERT (result == CY_RSLT_SUCCESS);

   retarget_io_init();

   /* initialize shell console */
   shell_init (my_shell_init);

   xTaskCreate (
      console_task,
      "shell_console",
      4000,
      (void *)NULL,
      OS_PRIORITY_NORMAL,
      &console_task_hdl);
}

const shell_cmd_t cmd_help = {
   .cmd = _cmd_help,
   .name = "help",
   .help_short = "show help",
   .help_long =
      "help [command]\n"
      "\n"
      "Without argument, show list of available commands. With argument,\n"
      "show help for given command.\n"};

SHELL_CMD (cmd_help);
